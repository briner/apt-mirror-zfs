#!/usr/bin/python3

# MANAGED BY CENTRAL IT (DO NOT EDIT THIS FILE)

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301 USA

import sys
import os
import subprocess
import datetime
import shlex
import argparse
import pathlib
import logging
import traceback
from logging.handlers import TimedRotatingFileHandler
import yaml
import re

PROGNAME = "apt-mirror-zfs"
DEBUG = True

ENV = os.environ.copy()
ENV['LC_ALL'] = 'C'
ENV["PATH"]="/sbin"+os.pathsep+ENV["PATH"] if ENV["PATH"] else "/sbin"

version = "0.1"

ZFSNAME_MIRROR = "pool_apt/mirror"
ZFSMOUNTPOINT_MIRROR = "/var/spool/apt-mirror/mirror"
ZFSNAME_CLONE_MIRROR_ROOT = "pool_apt/mirror/snap"
ZFSMOUNTPOINT_CLONE_MIRROR_ROOT = "/var/spool/apt-mirror/snap"
ZFS_CREATION_FORMAT = "%a %b %d %H:%M %Y"

# valid-until-min is an option in /etc/apt/sources.list which will augment
# the time for which a not updated repository (such as apt.unige.ch) is
# considered valid even if the date of the repostory is old
TRESHOLD_DAY_OF_VALID_UNTIL_MIN=8
DAY_MARGIN=1


LOG_ROTATE_PATH = "/var/log/{}.log".format(PROGNAME)
LOG_LEVEL = logging.DEBUG
LOG_LEVEL = logging.INFO

KEEP_WORKING_DAY = 7
KEEP_WEEK = 2
RUN_PATH = "/var/run/{}".format(PROGNAME)

FORMAT_SNAPHOT_SUFFIX = "%Y.%m.%d"

MAX_NUMBER_OF_SNAP_TO_DESTROY = 3

NOW = datetime.datetime.now()

# logging


my_logger = logging.getLogger(__name__)
my_logger.setLevel(LOG_LEVEL)
formatter = logging.Formatter("%(asctime)s;%(levelname)s;%(message)s")
rh = TimedRotatingFileHandler(LOG_ROTATE_PATH, when="W0", backupCount=4)
rh.setFormatter(formatter)
my_logger.addHandler(rh)
if sys.stdout.isatty():
    sh = logging.StreamHandler()
    formatter = logging.Formatter("%(message)s")
    sh.setFormatter(formatter)
    my_logger.addHandler(sh)


# main

def exe_cmd(cmd_str):
    my_logger.debug('execute cmd(%s):' % cmd_str)
    cmd = shlex.split(cmd_str)
    try:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE, shell=False,
                                cwd='/', env=ENV)
    except Exception as err:
        my_logger.info("cmd ({}) failed.".format(cmd_str))
        exc_type, exc_value, exc_traceback = sys.exc_info()
        tb_format_exception=traceback.format_exception(exc_type, exc_value
                                                       ,exc_traceback)
        my_logger.debug("show traceback output")
        for mline in tb_format_exception:
            for line in mline.split("\n"):
                if line:
                    my_logger.debug(line)
        raise err
    lout = [out.decode("utf-8").rstrip("\n") for out in proc.stdout.readlines()]
    lerr = [out.decode("utf-8").rstrip("\n") for out in proc.stderr.readlines()]
    proc.communicate()
    retcode = proc.wait()
    if retcode != 0:
        my_logger.info("cmd str({}) returns {}".format(cmd_str, retcode))
        for err in lerr:
            my_logger.info(err)
    return retcode, lout, lerr


def is_date_a_workday(date=datetime.date.today()):
    # christmass
    if date.month == 12 and date.day > 20:
        return False
    # new year do not do anything during the first week of the year
    if date.isocalendar()[1] == 1:
        return False
    # saturday or sunday
    if date.weekday() > 4:
        return False
    return True


def get_snaphotname_list():
    retcode, lout, lerr = exe_cmd("zfs list -Hrt snapshot -o name,ch.unige:created_by {}".format(ZFSNAME_MIRROR))
    lsnap = [out.split("\t")[0] for out in lout if PROGNAME == out.split("\t")[1]]
    return lsnap


def get_list_snapshot_unused():
    retcode, lout, lerr = exe_cmd("zfs list -Hrt snapshot -o name,ch.unige:created_by,clones {}".format(ZFSNAME_MIRROR))
    lsnap = []
    for out in lout:
        name, created_by, clones = out.split("\t")
        if created_by != PROGNAME:
            continue
        if clones != "":
            continue
        lsnap.append(name)
    return lsnap

def get_clone_list():
    retcode, lout, lerr = exe_cmd("zfs list -Hr -o name,ch.unige:created_by {}".format(ZFSNAME_CLONE_MIRROR_ROOT))
    lclone = [out.split("\t")[0] for out in lout if PROGNAME == out.split("\t")[1]]
    return lclone


def create_snapshot(snapshotname):
    cmd_str = "zfs snapshot -o ch.unige:created_by={} {}".format(PROGNAME, snapshotname)
    retcode, lout, lerr = exe_cmd(cmd_str)
    if retcode != 0:
        raise Exception("Unable to create snapshot from cmd({}).".format(cmd_str))


def create_clone(snapshotname, zfsname):
    cmd_str = "zfs clone -o ch.unige:created_by={} {} {}".format(PROGNAME, snapshotname, zfsname)
    retcode, lout, lerr = exe_cmd(cmd_str)
    if retcode != 0:
        raise Exception("Unable to create clone from cmd({}).".format(cmd_str))


def is_created_by_us(zfsname):
    cmd_str = "zfs get -Hpo value ch.unige:created_by {}".format(zfsname)
    retcode, lout, lerr = exe_cmd(cmd_str)
    if retcode != 0:
        raise Exception("Error on 'is_created_by_us' with cmd({}).".format(cmd_str))
    if lout[0] == PROGNAME:
        return True
    return False


def destroy_snapshot(snapshotname):
    if snapshotname.find("@") == -1:
        raise TypeError("snapshotnane ({}) should contain a '@'.".format(snapshotname))
    if not is_created_by_us(snapshotname):
        raise Exception("Do not destroy snapshot. {} is not ch.unige:created_by_ !".format(snapshotname))
    cmd_str = "zfs destroy -R {}".format(snapshotname)
    retcode, lout, lerr = exe_cmd("zfs destroy -R {}".format(snapshotname))
    if retcode != 0:
        raise Exception("Error on 'destroy_snapshot' with cmd({}).".format(cmd_str))
    return True


def destroy_clone(zfsname):
    if not is_created_by_us(zfsname):
        raise Exception("Do not destroy clone. {} is not ch.unige:created_by({}) !".format(zfsname, PROGNAME))
    cmd_str = "zfs destroy {}".format(zfsname)
    retcode, lout, lerr = exe_cmd(cmd_str)
    if retcode != 0:
        raise Exception("Error on 'destroy_clone' with cmd({}).".format(cmd_str))
    return True


def get_raw_property(zfsname, property_name):
    cmd_str = "zfs get -H -o value {} {}".format(property_name, zfsname)
    retcode, lout, lerr = exe_cmd(cmd_str)
    if retcode != 0:
        raise Exception("Error on 'get_raw_property' with cmd({}).".format(cmd_str))
    return lout[0]


def get_zfs_creation(zfsname):
    raw_creation = get_raw_property(zfsname, "creation")
    creation = datetime.datetime.strptime(raw_creation, ZFS_CREATION_FORMAT)
    return creation


def construct_slug_name(wdays=None, weeks=None):
    if (wdays is None) and (weeks is None):
        wdays = 0
    if (wdays is not None) and (weeks is not None):
        raise TypeError("wdays and weeks arguments can not be set at the same time.")

    ret_date = datetime.date.today()
    if weeks is not None:
        ret_date = ret_date - datetime.timedelta(days=ret_date.weekday())
        for i in range(weeks):
            ret_date = ret_date - datetime.timedelta(weeks=1)
            while not is_date_a_workday(ret_date):
                ret_date = ret_date - datetime.timedelta(weeks=1)
        slug_name = ret_date.strftime(FORMAT_SNAPHOT_SUFFIX)
    else:
        for i in range(wdays):
            ret_date = ret_date - datetime.timedelta(days=1)
            while not is_date_a_workday(ret_date):
                ret_date = ret_date - datetime.timedelta(days=1)
        slug_name = ret_date.strftime(FORMAT_SNAPHOT_SUFFIX)
    return slug_name


def slugname_2_date(slug_name):
    return datetime.datetime.strptime(slug_name, FORMAT_SNAPHOT_SUFFIX)


def extract_days_from_snap_lastdir(lastdir):
    '''
    extract how old could be a snap from its name:
    eg: working-day-0 returns 0
        working-day-2 returns 2
        week-0 returns 7
        week-1 returns 14
    '''
    match=re.search("^working-day-(\d+)$", lastdir)
    if match:
        days=int(match.groups()[0])
        return days

    match=re.search("^week-(\d+)$", lastdir)
    if match:
        days=7*(1+int(match.groups()[0]))
        return days

    raise Exception("lastdir ({}) not in ['week-X+', 'working-day-X+'] format.".format(lastdir))


def create_option_from_days(days):
    '''
    return the valid-until-min option used in /etc/apt/sources.list such as:
    deb [valid-until-min=<duration_in_seconds>] http://... strech main
    '''
    if days < TRESHOLD_DAY_OF_VALID_UNTIL_MIN:
        return ""
    days_with_margin= days + DAY_MARGIN
    seconds=days_with_margin * 24 * 60 * 60
    option="[valid-until-min={}]".format(seconds)
    return option




# main

def main_list_unused_snapshot():
    my_logger.debug("main_list_unused_snapshot")
    lsnap = get_list_snapshot_unused()
    for snap in lsnap:
        print(snap)


def main_list(is_verbose=False):
    my_logger.debug("main_list")
    cmd_str = "zfs list -r -o name,mountpoint,origin,ch.unige:created_by {}".format(ZFSNAME_CLONE_MIRROR_ROOT)
    retcode, lout, lerr = exe_cmd(cmd_str)
    print(cmd_str)
    print(os.linesep.join(lout))


def main_rotate(is_verbose=False, is_force=False):
    my_logger.debug("main_rotate")
    lweek_zfsname = []
    lwd_zfsname = []

    # is workday

    if not is_date_a_workday():
        if is_force:
            my_logger.info("Not a workday ! But argument '--force'. So let's continue")
        else:
            my_logger.info("Not a workday! Exit.")
            sys.exit()

    my_logger.info("Create snapshot of the day.")

    # create snapshot

    slug_name = construct_slug_name()
    snapshotname = "{}@{}".format(ZFSNAME_MIRROR, slug_name)
    if snapshotname in get_snaphotname_list():
        my_logger.warning("Snapshot ({}) already exist !".format(snapshotname))
    else:
        create_snapshot(snapshotname)

    # working-day : delete the working-day clones

    my_logger.info("Regenerate working day clone.")
    for wd_index in range(KEEP_WORKING_DAY):
        zfsname = os.path.join(ZFSNAME_CLONE_MIRROR_ROOT, "working-day-{}".format(wd_index))
        if zfsname in get_clone_list():
            destroy_clone(zfsname)

    # working-day : create the working-day clones

    for wd_index in range(KEEP_WORKING_DAY):
        zfsname = os.path.join(ZFSNAME_CLONE_MIRROR_ROOT, "working-day-{}".format(wd_index))
        slug_name = construct_slug_name(wdays=wd_index)
        snapshotname = "{}@{}".format(ZFSNAME_MIRROR, slug_name)
        if snapshotname in get_snaphotname_list():
            create_clone(snapshotname, zfsname)
            lwd_zfsname.append(zfsname)
        else:
            my_logger.info("Unable to create clone for snap({}). This snap does not exist.".format(snapshotname))

    # week : delete the week clones

    my_logger.info("Regenerate week clone.")
    for week_index in range(KEEP_WEEK):
        zfsname = os.path.join(ZFSNAME_CLONE_MIRROR_ROOT, "week-{}".format(week_index))
        if zfsname in get_clone_list():
            destroy_clone(zfsname)

    # week : create the week clones

    for week_index in range(KEEP_WEEK):
        zfsname = os.path.join(ZFSNAME_CLONE_MIRROR_ROOT, "week-{}".format(week_index))
        slug_name = construct_slug_name(weeks=week_index)
        snapshotname = "{}@{}".format(ZFSNAME_MIRROR, slug_name)
        if snapshotname in get_snaphotname_list():
            create_clone(snapshotname, zfsname)
            lweek_zfsname.append(zfsname)
        else:
            my_logger.info("Unable to create clone for snap({}). This snap does not exist.".format(snapshotname))

    # regenerate info in clone

    my_logger.info("regenerate info in clone")
    for zfsname in lwd_zfsname + lweek_zfsname:
        #
        lastdir = os.path.basename(zfsname)
        mountpoint = get_raw_property(zfsname, "mountpoint")
        slug_name = get_raw_property(zfsname, "origin").split("@")[1]
        slug_path = os.path.join(mountpoint, "DATE_{}".format(slug_name))
        pathlib.Path(slug_path).touch()
        monitoring_hook_path = os.path.join(mountpoint, "MONITORING_HOOK")
        pathlib.Path(monitoring_hook_path).touch()
        open(monitoring_hook_path,"w").write("This file is used by xymon to raise an alert if the snap is not young enough.\n")

        l_sourcesfn = [filename for filename in os.listdir(mountpoint) if
                       (filename.find("_sources") == 0) or (filename == "readme.txt")]
        for sourcesfn in l_sourcesfn:
            snap_dir = "snap/" + lastdir
            sourcesfp = os.path.join(mountpoint, sourcesfn)
            if os.path.islink(sourcesfp):
                # to avoid a file to be twiced processed: the file and their symlink
                continue
            sources_content = open(sourcesfp, "r").read()
            # rewrite the url of the sources.list with the snapdir
            org_server_path="apt.unige.ch/"
            new_server_path="apt.unige.ch/{}/".format(snap_dir)
            sources_new_content = sources_content.replace(org_server_path, new_server_path)
            # rewrite the deb entry with the option if needed
            days=extract_days_from_snap_lastdir(lastdir)
            option_valid_time_min=create_option_from_days(days)
            if option_valid_time_min:
                org_deb_http="deb http"
                new_deb_http="deb {} http".format(option_valid_time_min)
                sources_new_content = sources_new_content.replace(org_deb_http, new_deb_http)
                org_deb_src_http="deb-src http"
                new_deb_src_http="deb-src {} http".format(option_valid_time_min)
                sources_new_content = sources_new_content.replace(org_deb_src_http, new_deb_src_http)
            #
            open(sourcesfp, "w").write(sources_new_content)

    # destroy snapshot unused

    my_logger.info("destroy snapshot unused (not related to clones).")
    lsnap = get_list_snapshot_unused()
    if len(lsnap) > MAX_NUMBER_OF_SNAP_TO_DESTROY:
        my_logger.error("length of lsnap to delete is bigger than {}! Exit.".format(MAX_NUMBER_OF_SNAP_TO_DESTROY))
        my_logger.info("to remove it manually, try something like: (hint: to not forget to remove 'echo') ")
        my_logger.info("{} list-unused-snapshot | grep @ |xargs -tI@ echo zfs destroy @".format(PROGNAME))
        sys.exit(1)
    for snap in lsnap:
        destroy_snapshot(snap)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='tools to do snapshot of the apt-mirror db')
    subparsers = parser.add_subparsers(help="sub-command-help")

    # list

    list_parser = subparsers.add_parser("list", help="list the snapshots")
    list_parser.set_defaults(name="list")
    list_parser.add_argument("-v", "--verbose", help="increase output verbosity",
                             action="store_true")

    # rotate

    rotate_parser = subparsers.add_parser("rotate", help="rotate the snapshot")
    rotate_parser.set_defaults(name="rotate")
    rotate_parser.add_argument("-v", "--verbose", help="increase output verbosity",
                               action="store_true")
    rotate_parser.add_argument("-f", "--force", help="force it", action="store_true")

    # snaphot_without_clones

    rotate_parser = subparsers.add_parser("list-unused-snapshot", help="rotate the snapshot")
    rotate_parser.set_defaults(name="list-unused-snapshot")

    args = parser.parse_args()
    if hasattr(args, "name"):
        if "list" == args.name:
            main_list(is_verbose=args.verbose)
        elif "rotate" == args.name:
            main_rotate(is_verbose=args.verbose, is_force=args.force)
        elif "list-unused-snapshot" == args.name:
            main_list_unused_snapshot()
    else:
        parser.print_help()
